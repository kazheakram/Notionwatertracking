<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Water Tracker Widget</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for the widget */
        body {
            font-family: 'Inter', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #ffffff; /* Page background is white */
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
        }

        #widget-container {
            width: 250px; /* Small fixed width for Notion dashboard */
            height: auto;
            background-color: #ffffff; /* Widget background is white */
            border-radius: 20px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            text-align: center;
        }

        canvas {
            border-radius: 50%; /* Ensures the canvas looks circular */
            background-color: #fce4ec; /* Very light pink background for the empty part */
            box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.05); /* Subtle inner shadow */
        }

        .input-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
        }

        .input-group label {
            font-size: 0.9em;
            color: #7f8c8d;
            margin-bottom: 5px;
        }

        .input-group input[type="number"] {
            width: calc(100% - 20px);
            padding: 8px 10px;
            border: 1px solid #e0e0e0;
            border-radius: 10px;
            font-size: 1em;
            text-align: center;
            -moz-appearance: textfield; /* Hide arrows for Firefox */
        }

        /* Hide arrows for Chrome, Safari, Edge */
        .input-group input[type="number"]::-webkit-outer-spin-button,
        .input-group input[type="number"]::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }

        .input-group button {
            background-color: #f48fb1; /* Baby pink button */
            color: white;
            padding: 8px 15px;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-size: 0.9em;
            margin-top: 10px;
            transition: background-color 0.3s ease, transform 0.1s ease;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }

        .input-group button:hover {
            background-color: #f06292; /* Slightly darker pink on hover */
            transform: translateY(-1px);
        }

        .input-group button:active {
            transform: translateY(0);
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        .input-group button:disabled {
            background-color: #ffccd5; /* Lighter pink when disabled */
            cursor: not-allowed;
            box-shadow: none;
            transform: none;
        }

        #status-text {
            font-size: 1.1em;
            font-weight: bold;
            color: #555;
            margin-top: 10px;
        }

        #goal-display {
            font-size: 0.9em;
            color: #888;
        }

        .unit-selector {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 10px;
        }
        .unit-selector label {
            font-size: 0.9em;
            color: #7f8c8d;
        }
        .unit-selector select {
            padding: 6px 10px;
            border: 1px solid #e0e0e0;
            border-radius: 10px;
            font-size: 0.9em;
            background-color: #fefefe;
            cursor: pointer;
        }
    </style>
</head>
<body class="flex items-center justify-center min-h-screen">
    <div id="widget-container" class="rounded-2xl shadow-lg bg-white p-5 flex flex-col items-center gap-4">
        <h2 class="text-xl font-semibold text-gray-700"></h2>
        <canvas id="waterCanvas" width="150" height="150" class="rounded-full"></canvas>
        <div id="status-text" class="text-lg font-bold text-gray-800"></div>
        <div id="goal-display" class="text-sm text-gray-600"></div>

        <div class="unit-selector">
            <label for="unitSelect">Unit:</label>
            <select id="unitSelect" class="rounded-md">
                <option value="ml">Milliliters (ml)</option>
                <option value="L">Liters (L)</option>
            </select>
        </div>

        <div class="input-group w-full">
            <label for="currentWater" class="text-sm text-gray-700 mb-1"><span id="currentInputLabel">Current Intake</span>:</label>
            <input type="number" id="currentWater" value="0" min="0" step="any" class="w-full p-2 border border-gray-300 rounded-md text-center">
            <button id="addWaterBtn" class="mt-2 bg-pink-400 text-white py-2 px-4 rounded-lg shadow-md hover:bg-pink-500 transition-colors">Update Intake</button>
        </div>

        <div class="input-group w-full">
            <label for="waterGoal" class="text-sm text-gray-700 mb-1"><span id="goalInputLabel">Set Goal</span>:</label>
            <input type="number" id="waterGoal" value="2000" min="100" step="any" class="w-full p-2 border border-gray-300 rounded-md text-center">
            <button id="setGoalBtn" class="mt-2 bg-pink-400 text-white py-2 px-4 rounded-lg shadow-md hover:bg-pink-500 transition-colors">Set Goal</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('waterCanvas');
        const ctx = canvas.getContext('2d');
        const currentWaterInput = document.getElementById('currentWater');
        const waterGoalInput = document.getElementById('waterGoal');
        const addWaterBtn = document.getElementById('addWaterBtn');
        const setGoalBtn = document.getElementById('setGoalBtn');
        const statusText = document.getElementById('status-text');
        const goalDisplay = document.getElementById('goal-display');
        const unitSelect = document.getElementById('unitSelect');
        const currentInputLabel = document.getElementById('currentInputLabel');
        const goalInputLabel = document.getElementById('goalInputLabel');

        let currentWaterML = 0; // Current water intake in ML (internal base unit)
        let waterGoalML = 2000; // Daily water goal in ML (internal base unit)
        let waveOffset = 0; // For water animation
        let currentUnit = 'ml'; // Default unit
        let animationInterval = null; // To store the animation interval ID

        // Conversion factors
        const ML_TO_LITER = 1000;

        // Function to save data to localStorage
        function saveData() {
            try {
                localStorage.setItem('waterTrackerCurrentML', currentWaterML);
                localStorage.setItem('waterTrackerGoalML', waterGoalML);
                localStorage.setItem('waterTrackerUnit', currentUnit);
            } catch (e) {
                console.error("Failed to save to localStorage:", e);
                // Optionally show a user-friendly message
            }
        }

        // Function to load data from localStorage
        function loadData() {
            try {
                const savedCurrent = localStorage.getItem('waterTrackerCurrentML');
                const savedGoal = localStorage.getItem('waterTrackerGoalML');
                const savedUnit = localStorage.getItem('waterTrackerUnit');

                if (savedCurrent !== null) {
                    currentWaterML = parseFloat(savedCurrent);
                }
                if (savedGoal !== null) {
                    waterGoalML = parseFloat(savedGoal);
                }
                if (savedUnit !== null) {
                    currentUnit = savedUnit;
                }
                unitSelect.value = currentUnit; // Set dropdown to saved unit
                updateInputAndDisplayBasedOnUnit(); // Update UI after loading
            } catch (e) {
                console.error("Failed to load from localStorage:", e);
                // Data might be corrupted or storage denied, reset to defaults
                currentWaterML = 0;
                waterGoalML = 2000;
                currentUnit = 'ml';
                unitSelect.value = currentUnit;
                updateInputAndDisplayBasedOnUnit();
            }
        }

        // Converts value from ML to selected unit
        function convertMLToSelectedUnit(valueML) {
            if (currentUnit === 'L') {
                return (valueML / ML_TO_LITER).toFixed(2); // Keep 2 decimal places for liters
            }
            return valueML.toFixed(0); // No decimals for ml
        }

        // Converts value from selected unit to ML
        function convertSelectedUnitToML(value) {
            if (currentUnit === 'L') {
                return value * ML_TO_LITER;
            }
            return value;
        }

        // Updates input fields and labels based on the selected unit
        function updateInputAndDisplayBasedOnUnit() {
            currentWaterInput.value = convertMLToSelectedUnit(currentWaterML);
            waterGoalInput.value = convertMLToSelectedUnit(waterGoalML);
            currentInputLabel.textContent = `Current Intake (${currentUnit})`;
            goalInputLabel.textContent = `Set Goal (${currentUnit})`;
            drawWater(); // Redraw canvas with new unit display
        }

        // Draws the water filling animation
        function drawWater() {
            ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear canvas

            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const radius = Math.min(canvas.width, canvas.height) / 2 - 5; // -5 for a little padding

            // Background circle (empty part)
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
            ctx.fillStyle = '#fce4ec'; // Very light baby pink
            ctx.fill();

            // Calculate fill percentage based on internal ML values
            let fillPercentage = currentWaterML / waterGoalML;
            if (fillPercentage > 1) fillPercentage = 1; // Cap at 100%
            if (fillPercentage < 0) fillPercentage = 0; // Cap at 0%

            // Water color
            const waterColor = '#f48fb1'; // Baby pink for the water

            // Calculate water height
            const waterHeight = fillPercentage * (radius * 2);
            const waterY = canvas.height - waterHeight; // Y-coordinate of the bottom of the water

            // Draw water (rectangular part that fills up)
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, 0, Math.PI * 2); // Clip to the circle shape
            ctx.clip();

            ctx.fillStyle = waterColor;
            ctx.fillRect(0, waterY, canvas.width, canvas.height - waterY); // Fill rectangle from bottom up

            // Draw animated wave at the top of the water
            ctx.beginPath();
            ctx.moveTo(0, waterY);
            for (let i = 0; i <= canvas.width; i += 5) {
                // Adjust wave amplitude and frequency for a smoother look
                const waveAmplitude = 5; // Height of the wave
                const waveFrequency = 0.05; // How many waves across the width
                const yOffset = Math.sin((i * waveFrequency) + waveOffset) * waveAmplitude;
                ctx.lineTo(i, waterY + yOffset);
            }
            ctx.lineTo(canvas.width, canvas.height);
            ctx.lineTo(0, canvas.height);
            ctx.closePath();
            ctx.fill();

            // Outline for the circle
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
            ctx.strokeStyle = '#f8bbd0'; // Slightly darker baby pink for border
            ctx.lineWidth = 3;
            ctx.stroke();

            // Update status text and goal display using selected unit
            statusText.textContent = `${convertMLToSelectedUnit(currentWaterML)} ${currentUnit} / ${convertMLToSelectedUnit(waterGoalML)} ${currentUnit}`;
            goalDisplay.textContent = `Goal: ${convertMLToSelectedUnit(waterGoalML)} ${currentUnit}`;

            // Check if goal is reached
            if (currentWaterML >= waterGoalML && waterGoalML > 0) {
                statusText.textContent = 'Goal Reached! �';
            } else if (currentWaterML === 0 && waterGoalML === 0) {
                statusText.textContent = 'Set your goal!';
            }
        }

        // Main animation loop for wave
        function animateWave() {
            waveOffset += 0.05; // Speed of the wave
            drawWater();
            requestAnimationFrame(animateWave);
        }

        // Function to animate filling when intake is updated
        function animateFill(targetWaterML) {
            // Disable buttons during animation
            addWaterBtn.disabled = true;
            setGoalBtn.disabled = true;
            unitSelect.disabled = true;

            const startWaterML = currentWaterML;
            const difference = targetWaterML - startWaterML;
            const animationDuration = 1000; // 1 second for the animation
            const frames = 60; // frames per second
            const incrementPerFrame = difference / (animationDuration / (1000 / frames)); // Amount to add per frame
            let currentFrame = 0;

            if (animationInterval) {
                clearInterval(animationInterval); // Clear any existing animation
            }

            animationInterval = setInterval(() => {
                currentWaterML = startWaterML + (incrementPerFrame * currentFrame);
                // Ensure we don't overshoot the target if there are floating point inaccuracies
                if (difference > 0) { // Filling up
                    if (currentWaterML >= targetWaterML) {
                        currentWaterML = targetWaterML;
                        clearInterval(animationInterval);
                        animationInterval = null;
                        saveData(); // Save data after animation completes
                        // Re-enable buttons
                        addWaterBtn.disabled = false;
                        setGoalBtn.disabled = false;
                        unitSelect.disabled = false;
                    }
                } else { // Decreasing (if input is less than current, though normally we'd add)
                    if (currentWaterML <= targetWaterML) {
                        currentWaterML = targetWaterML;
                        clearInterval(animationInterval);
                        animationInterval = null;
                        saveData(); // Save data after animation completes
                        // Re-enable buttons
                        addWaterBtn.disabled = false;
                        setGoalBtn.disabled = false;
                        unitSelect.disabled = false;
                    }
                }
                drawWater(); // Draw current state
                currentFrame++;
            }, 1000 / frames); // Run at ~60 FPS
        }


        // Event Listeners
        addWaterBtn.addEventListener('click', () => {
            let amountInSelectedUnit = parseFloat(currentWaterInput.value);
            if (!isNaN(amountInSelectedUnit) && amountInSelectedUnit >= 0) {
                const targetWaterML = convertSelectedUnitToML(amountInSelectedUnit);
                animateFill(targetWaterML); // Trigger the filling animation
            } else {
                currentWaterInput.value = convertMLToSelectedUnit(currentWaterML); // Reset to current valid value if input is bad
            }
        });

        setGoalBtn.addEventListener('click', () => {
            let newGoalInSelectedUnit = parseFloat(waterGoalInput.value);
            // Ensure goal is positive when converted to ML
            if (!isNaN(newGoalInSelectedUnit) && convertSelectedUnitToML(newGoalInSelectedUnit) > 0) {
                waterGoalML = convertSelectedUnitToML(newGoalInSelectedUnit); // Convert to ML for internal storage
                saveData();
                drawWater(); // Redraw immediately
            } else {
                waterGoalInput.value = convertMLToSelectedUnit(waterGoalML); // Reset to current valid value if input is bad
            }
        });

        unitSelect.addEventListener('change', (event) => {
            currentUnit = event.target.value;
            saveData();
            updateInputAndDisplayBasedOnUnit(); // Update UI when unit changes
        });

        // Initialize on window load
        window.onload = function() {
            loadData(); // Load saved data first
            animateWave(); // Start the wave animation
        };
    </script>
</body>
</html>
�
