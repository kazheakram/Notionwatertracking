<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Water Tracker Widget</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for the widget */
        body {
            font-family: 'Inter', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #ffffff; /* Page background is white */
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
        }

        #widget-container {
            width: 250px; /* Small fixed width for Notion dashboard */
            height: auto;
            background-color: #ffffff; /* Widget background is white */
            border-radius: 20px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            text-align: center;
        }

        canvas {
            border-radius: 50%; /* Ensures the canvas looks circular */
            background-color: #fce4ec; /* Very light pink background for the empty part */
            box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.05); /* Subtle inner shadow */
        }

        .input-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
        }

        .input-group label {
            font-size: 0.9em;
            color: #7f8c8d;
            margin-bottom: 5px;
        }

        .input-group input[type="number"] {
            width: calc(100% - 20px);
            padding: 8px 10px;
            border: 1px solid #e0e0e0;
            border-radius: 10px;
            font-size: 1em;
            text-align: center;
            -moz-appearance: textfield; /* Hide arrows for Firefox */
        }

        /* Hide arrows for Chrome, Safari, Edge */
        .input-group input[type="number"]::-webkit-outer-spin-button,
        .input-group input[type="number"]::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }

        .input-group button {
            background-color: #f48fb1; /* Baby pink button */
            color: white;
            padding: 8px 15px;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-size: 0.9em;
            margin-top: 10px;
            transition: background-color 0.3s ease, transform 0.1s ease;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }

        .input-group button:hover {
            background-color: #f06292; /* Slightly darker pink on hover */
            transform: translateY(-1px);
        }

        .input-group button:active {
            transform: translateY(0);
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        .input-group button:disabled {
            background-color: #ffccd5; /* Lighter pink when disabled */
            cursor: not-allowed;
            box-shadow: none;
            transform: none;
        }

        #status-text {
            font-size: 1.1em;
            font-weight: bold;
            color: #555;
            margin-top: 10px;
        }

        #goal-display {
            font-size: 0.9em;
            color: #888;
        }

        .unit-selector {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 10px;
        }
        .unit-selector label {
            font-size: 0.9em;
            color: #7f8c8d;
        }
        .unit-selector select {
            padding: 6px 10px;
            border: 1px solid #e0e0e0;
            border-radius: 10px;
            font-size: 0.9em;
            background-color: #fefefe;
            cursor: pointer;
        }

        #resetBtn {
            background-color: #f8bbd0; /* A lighter pink for reset */
            color: #555;
            padding: 6px 12px;
            font-size: 0.8em;
            margin-top: 15px; /* Add some space above it */
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.08);
        }

        #resetBtn:hover {
            background-color: #fce4ec; /* Even lighter on hover */
            color: #333;
        }

        #loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(255, 255, 255, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.2em;
            color: #f48fb1;
            z-index: 1000;
            border-radius: 20px;
        }
    </style>
</head>
<body class="flex items-center justify-center min-h-screen">
    <div id="widget-container" class="rounded-2xl shadow-lg bg-white p-5 flex flex-col items-center gap-4 relative">
        <div id="loading-overlay">Loading...</div>
        <h2 class="text-xl font-semibold text-gray-700"></h2>
        <canvas id="waterCanvas" width="150" height="150" class="rounded-full"></canvas>
        <div id="status-text" class="text-lg font-bold text-gray-800"></div>
        <div id="goal-display" class="text-sm text-gray-600"></div>

        <div class="unit-selector">
            <label for="unitSelect">Unit:</label>
            <select id="unitSelect" class="rounded-md">
                <option value="ml">Milliliters (ml)</option>
                <option value="L">Liters (L)</option>
            </select>
        </div>

        <div class="input-group w-full">
            <label for="currentWater" class="text-sm text-gray-700 mb-1"><span id="currentInputLabel">Add Intake</span>:</label>
            <input type="number" id="currentWater" value="0" min="0" step="any" class="w-full p-2 border border-gray-300 rounded-md text-center">
            <button id="addWaterBtn" class="mt-2 bg-pink-400 text-white py-2 px-4 rounded-lg shadow-md hover:bg-pink-500 transition-colors">Add Water</button>
        </div>

        <div class="input-group w-full">
            <label for="waterGoal" class="text-sm text-gray-700 mb-1"><span id="goalInputLabel">Set Goal</span>:</label>
            <input type="number" id="waterGoal" value="2000" min="100" step="any" class="w-full p-2 border border-gray-300 rounded-md text-center">
            <button id="setGoalBtn" class="mt-2 bg-pink-400 text-white py-2 px-4 rounded-lg shadow-md hover:bg-pink-500 transition-colors">Set Goal</button>
        </div>

        <button id="resetBtn" class="bg-pink-300 text-gray-700 py-1 px-3 rounded-lg shadow-sm hover:bg-pink-200 transition-colors">Reset Daily Intake</button>
    </div>

    <script type="module">
        // Firebase Imports
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, onSnapshot } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Global variables provided by the Canvas environment (MUST BE USED)
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        const auth = getAuth(app);

        let userId = null; // Will be set after authentication
        let isAuthReady = false; // Flag to ensure Firestore operations only happen after auth

        // Get DOM elements
        const canvas = document.getElementById('waterCanvas');
        const ctx = canvas.getContext('2d');
        const currentWaterInput = document.getElementById('currentWater');
        const waterGoalInput = document.getElementById('waterGoal');
        const addWaterBtn = document.getElementById('addWaterBtn');
        const setGoalBtn = document.getElementById('setGoalBtn');
        const statusText = document.getElementById('status-text');
        const goalDisplay = document.getElementById('goal-display');
        const unitSelect = document.getElementById('unitSelect');
        const currentInputLabel = document.getElementById('currentInputLabel');
        const goalInputLabel = document.getElementById('goalInputLabel');
        const resetBtn = document.getElementById('resetBtn');
        const loadingOverlay = document.getElementById('loading-overlay');

        // State variables
        let currentWaterML = 0; // Current water intake in ML (internal base unit)
        let waterGoalML = 2000; // Daily water goal in ML (internal base unit)
        let waveOffset = 0; // For water animation
        let currentUnit = 'ml'; // Default unit
        let animationInterval = null; // To store the animation interval ID

        // Conversion factors
        const ML_TO_LITER = 1000;

        // Firestore document reference
        let userDocRef;

        // Function to get today's date in YYYY-MM-DD format (UTC to avoid timezone issues with daily reset)
        function getTodayDateString() {
            const today = new Date();
            // Get UTC date components to ensure consistent daily resets regardless of user's timezone
            const year = today.getUTCFullYear();
            const month = String(today.getUTCMonth() + 1).padStart(2, '0'); // Months are 0-indexed
            const day = String(today.getUTCDate()).padStart(2, '0');
            return `${year}-${month}-${day}`;
        }

        // Function to save data to Firestore
        async function saveData() {
            if (!isAuthReady || !userId || !userDocRef) {
                console.warn("Authentication not ready or userId/userDocRef not set. Cannot save data.");
                return;
            }
            try {
                // Set the data in Firestore. `merge: true` ensures only specified fields are updated.
                await setDoc(userDocRef, {
                    currentWaterML: currentWaterML,
                    waterGoalML: waterGoalML,
                    currentUnit: currentUnit,
                    lastResetDate: getTodayDateString()
                }, { merge: true });
                // console.log("Data saved to Firestore.");
            } catch (e) {
                console.error("Error saving data to Firestore:", e);
                // In a real app, you might show a user-friendly error message here
            }
        }

        // Function to load data from Firestore or initialize
        async function loadDataAndSetupRealtimeListener() {
            if (!userId) {
                console.warn("User ID not available yet for loading data.");
                return;
            }

            userDocRef = doc(db, 'artifacts', appId, 'users', userId, 'waterTracker', 'data');
            // console.log("Firestore document path:", userDocRef.path);

            // Set up real-time listener for the document
            onSnapshot(userDocRef, (docSnap) => {
                if (docSnap.exists()) {
                    const data = docSnap.data();
                    const lastResetDate = data.lastResetDate;
                    const todayDate = getTodayDateString();

                    // Check for daily reset condition
                    if (lastResetDate !== todayDate) {
                        currentWaterML = 0; // Reset intake for new day
                        saveData(); // Save the reset state (this will update lastResetDate too)
                    } else {
                        currentWaterML = data.currentWaterML !== undefined ? data.currentWaterML : 0;
                    }

                    waterGoalML = data.waterGoalML !== undefined ? data.waterGoalML : 2000;
                    currentUnit = data.currentUnit !== undefined ? data.currentUnit : 'ml';

                    // Update UI inputs and display
                    unitSelect.value = currentUnit;
                    updateInputAndDisplayBasedOnUnit();
                } else {
                    // Document does not exist, initialize with default values
                    console.log("No existing data found in Firestore, initializing...");
                    currentWaterML = 0;
                    waterGoalML = 2000;
                    currentUnit = 'ml';
                    saveData(); // Save initial data to Firestore
                }
                loadingOverlay.style.display = 'none'; // Hide loading overlay once data is loaded/initialized
            }, (error) => {
                console.error("Error getting real-time updates from Firestore:", error);
                loadingOverlay.style.display = 'none'; // Hide loading on error too
                // Fallback to local defaults if Firestore fails badly
                currentWaterML = 0;
                waterGoalML = 2000;
                currentUnit = 'ml';
                unitSelect.value = currentUnit;
                updateInputAndDisplayBasedOnUnit();
            });
        }

        // Converts value from ML to selected unit
        function convertMLToSelectedUnit(valueML) {
            if (currentUnit === 'L') {
                return (valueML / ML_TO_LITER).toFixed(2); // Keep 2 decimal places for liters
            }
            return valueML.toFixed(0); // No decimals for ml
        }

        // Converts value from selected unit to ML
        function convertSelectedUnitToML(value) {
            if (currentUnit === 'L') {
                return value * ML_TO_LITER;
            }
            return value;
        }

        // Updates input fields and labels based on the selected unit
        function updateInputAndDisplayBasedOnUnit() {
            waterGoalInput.value = convertMLToSelectedUnit(waterGoalML);
            currentInputLabel.textContent = `Add Intake (${currentUnit})`;
            goalInputLabel.textContent = `Set Goal (${currentUnit})`;
            drawWater(); // Redraw canvas with new unit display
        }

        // Draws the water filling animation
        function drawWater() {
            ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear canvas

            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const radius = Math.min(canvas.width, canvas.height) / 2 - 5; // -5 for a little padding

            // Background circle (empty part)
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
            ctx.fillStyle = '#fce4ec'; // Very light baby pink
            ctx.fill();

            // Calculate fill percentage based on internal ML values
            let fillPercentage = currentWaterML / waterGoalML;
            if (fillPercentage > 1) fillPercentage = 1; // Cap at 100%
            if (fillPercentage < 0) fillPercentage = 0; // Cap at 0%

            // Water color
            const waterColor = '#f48fb1'; // Baby pink for the water

            // Calculate water height
            const waterHeight = fillPercentage * (radius * 2);
            const waterY = canvas.height - waterHeight; // Y-coordinate of the bottom of the water

            // Draw water (rectangular part that fills up)
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, 0, Math.PI * 2); // Clip to the circle shape
            ctx.clip();

            ctx.fillStyle = waterColor;
            ctx.fillRect(0, waterY, canvas.width, canvas.height - waterY); // Fill rectangle from bottom up

            // Draw animated wave at the top of the water
            ctx.beginPath();
            ctx.moveTo(0, waterY);
            for (let i = 0; i <= canvas.width; i += 5) {
                // Adjust wave amplitude and frequency for a smoother look
                const waveAmplitude = 5; // Height of the wave
                const waveFrequency = 0.05; // How many waves across the width
                const yOffset = Math.sin((i * waveFrequency) + waveOffset) * waveAmplitude;
                ctx.lineTo(i, waterY + yOffset);
            }
            ctx.lineTo(canvas.width, canvas.height);
            ctx.lineTo(0, canvas.height);
            ctx.closePath();
            ctx.fill();

            // Outline for the circle
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
            ctx.strokeStyle = '#f8bbd0'; // Slightly darker baby pink for border
            ctx.lineWidth = 3;
            ctx.stroke();

            // Update status text and goal display using selected unit
            statusText.textContent = `${convertMLToSelectedUnit(currentWaterML)} ${currentUnit} / ${convertMLToSelectedUnit(waterGoalML)} ${currentUnit}`;
            goalDisplay.textContent = `Goal: ${convertMLToSelectedUnit(waterGoalML)} ${currentUnit}`;

            // Check if goal is reached
            if (currentWaterML >= waterGoalML && waterGoalML > 0) {
                statusText.textContent = 'Goal Reached! 🎉';
            } else if (currentWaterML === 0 && waterGoalML === 0) {
                statusText.textContent = 'Set your goal!';
            }
        }

        // Main animation loop for wave
        function animateWave() {
            waveOffset += 0.05; // Speed of the wave
            drawWater();
            requestAnimationFrame(animateWave);
        }

        // Function to animate filling when intake is updated
        function animateFill(targetWaterML) {
            // Disable buttons during animation
            addWaterBtn.disabled = true;
            setGoalBtn.disabled = true;
            unitSelect.disabled = true;
            resetBtn.disabled = true;

            const startWaterML = currentWaterML;
            const difference = targetWaterML - startWaterML;
            const animationDuration = 1000; // 1 second for the animation
            const frames = 60; // frames per second
            const incrementPerFrame = difference / (animationDuration / (1000 / frames)); // Amount to add per frame
            let currentFrame = 0;

            if (animationInterval) {
                clearInterval(animationInterval); // Clear any existing animation
            }

            animationInterval = setInterval(() => {
                currentWaterML = startWaterML + (incrementPerFrame * currentFrame);
                // Ensure we don't overshoot the target if there are floating point inaccuracies
                if (difference > 0) { // Filling up
                    if (currentWaterML >= targetWaterML) {
                        currentWaterML = targetWaterML;
                        clearInterval(animationInterval);
                        animationInterval = null;
                        saveData(); // Save data after animation completes
                        // Re-enable buttons
                        addWaterBtn.disabled = false;
                        setGoalBtn.disabled = false;
                        unitSelect.disabled = false;
                        resetBtn.disabled = false;
                    }
                } else { // Decreasing (if input is less than current, though normally we'd add)
                    if (currentWaterML <= targetWaterML) {
                        currentWaterML = targetWaterML;
                        clearInterval(animationInterval);
                        animationInterval = null;
                        saveData(); // Save data after animation completes
                        // Re-enable buttons
                        addWaterBtn.disabled = false;
                        setGoalBtn.disabled = false;
                        unitSelect.disabled = false;
                        resetBtn.disabled = false;
                    }
                }
                drawWater(); // Draw current state
                currentFrame++;
            }, 1000 / frames); // Run at ~60 FPS
        }


        // Event Listeners
        addWaterBtn.addEventListener('click', () => {
            let amountToAddInSelectedUnit = parseFloat(currentWaterInput.value);
            if (!isNaN(amountToAddInSelectedUnit) && amountToAddInSelectedUnit >= 0) {
                const amountToAddML = convertSelectedUnitToML(amountToAddInSelectedUnit);
                const newTotalWaterML = currentWaterML + amountToAddML; // Add to current total
                animateFill(newTotalWaterML); // Trigger the filling animation
                currentWaterInput.value = '0'; // Reset input after adding
            } else {
                currentWaterInput.value = '0'; // Reset to 0 if input is invalid
            }
        });

        setGoalBtn.addEventListener('click', () => {
            let newGoalInSelectedUnit = parseFloat(waterGoalInput.value);
            // Ensure goal is positive when converted to ML
            if (!isNaN(newGoalInSelectedUnit) && convertSelectedUnitToML(newGoalInSelectedUnit) > 0) {
                waterGoalML = convertSelectedUnitToML(newGoalInSelectedUnit); // Convert to ML for internal storage
                saveData(); // This will trigger onSnapshot to update UI
            } else {
                waterGoalInput.value = convertMLToSelectedUnit(waterGoalML); // Reset to current valid value if input is bad
            }
        });

        unitSelect.addEventListener('change', (event) => {
            currentUnit = event.target.value;
            saveData(); // This will trigger onSnapshot to update UI
        });

        // Manual reset button event listener
        resetBtn.addEventListener('click', () => {
            currentWaterML = 0; // Reset current intake to 0
            saveData(); // Save the reset state to Firestore, which will update UI via onSnapshot
        });

        // --- Firebase Authentication Setup and Data Loading ---
        // Listen for authentication state changes
        onAuthStateChanged(auth, async (user) => {
            if (user) {
                userId = user.uid;
                // console.log("User authenticated:", userId);
                isAuthReady = true;
                await loadDataAndSetupRealtimeListener();
            } else {
                // Not signed in, attempt anonymous sign-in or use provided token
                if (initialAuthToken) {
                    try {
                        await signInWithCustomToken(auth, initialAuthToken);
                    } catch (error) {
                        console.error("Error signing in with custom token:", error);
                        // Fallback to anonymous sign-in if custom token fails
                        await signInAnonymously(auth);
                    }
                } else {
                    await signInAnonymously(auth);
                }
            }
        });

        // Initialize on window load: Start wave animation and wait for authentication
        window.onload = function() {
            animateWave(); // Start the wave animation immediately
        };
    </script>
</body>
</html>
